generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          Int      @id @default(autoincrement())
  email       String   @unique
  password    String
  name        String?
  isAdmin     Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // User's platform and game collections
  userPlatforms UserPlatform[]
  gameCollection UserGame[]
}

model Platform {
  id          Int      @id @default(autoincrement())
  name        String
  imageUrl    String?  // Platform logo/image from IGDB
  description String?
  igdbId      Int?     @unique // IGDB platform ID for matching
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  userPlatforms UserPlatform[]
  games         UserGame[]
}

model UserPlatform {
  id         Int      @id @default(autoincrement())
  userId     Int
  platformId Int
  status     PlatformStatus // OWNED or WISHLISTED
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user     User     @relation(fields: [userId], references: [id])
  platform Platform @relation(fields: [platformId], references: [id])

  @@unique([userId, platformId, status]) // Prevent duplicates
}

model UserGame {
  id          Int      @id @default(autoincrement())
  userId      Int
  platformId  Int
  
  // Game details (from IGDB or user input)
  title       String
  description String?
  imageUrl    String?
  igdbId      Int?     // IGDB game ID if from API
  
  // Collection details
  status      GameStatus    // OWNED or WISHLISTED
  condition   GameCondition? // Only for owned games
  notes       String?       // User notes
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user     User     @relation(fields: [userId], references: [id])
  platform Platform @relation(fields: [platformId], references: [id])

  @@unique([userId, platformId, igdbId, status]) // Prevent exact duplicates
}

enum PlatformStatus {
  OWNED
  WISHLISTED
}

enum GameStatus {
  OWNED
  WISHLISTED
}

enum GameCondition {
  MINT         // Perfect condition
  NEAR_MINT    // Very minor wear
  EXCELLENT    // Light wear but fully functional
  VERY_GOOD    // Moderate wear but good condition
  GOOD         // Noticeable wear but works well
  FAIR         // Significant wear but functional
  POOR         // Heavy wear, may have issues
  SEALED       // Brand new, never opened
}
